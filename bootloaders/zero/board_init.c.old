/*
  Copyright (c) 2015 Arduino LLC.  All right reserved.

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
  See the GNU Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/

void system_init(void)
{
  /* Configure flash wait states */
  NVMCTRL->CTRLB.bit.RWS = FLASH_WAIT_STATES;

  /* Set OSC8M prescalar to divide by 1 */
  SYSCTRL->OSC8M.bit.PRESC = 0;

  /* Configure OSC8M as source for GCLK_GEN0 */
  GCLK_GENCTRL_Type genctrl={0};
  uint32_t temp_genctrl;
  GCLK->GENCTRL.bit.ID = 0; /* GENERATOR_ID - GCLK_GEN_0 */
  while(GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY);
  temp_genctrl = GCLK->GENCTRL.reg;
  genctrl.bit.SRC = GCLK_GENCTRL_SRC_OSC8M_Val;
  genctrl.bit.GENEN = true;
  genctrl.bit.RUNSTDBY = false;
  GCLK->GENCTRL.reg = (genctrl.reg | temp_genctrl);
  while(GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY);

#if SAM_BA_INTERFACE == SAM_BA_USBCDC_ONLY  ||  SAM_BA_INTERFACE == SAM_BA_BOTH_INTERFACES
  SYSCTRL_DFLLCTRL_Type dfllctrl_conf = {0};
  SYSCTRL_DFLLVAL_Type dfllval_conf = {0};
  uint32_t coarse =( *((uint32_t *)(NVMCTRL_OTP4)
                    + (NVM_SW_CALIB_DFLL48M_COARSE_VAL / 32))
                    >> (NVM_SW_CALIB_DFLL48M_COARSE_VAL % 32))
                    & ((1 << 6) - 1);
  if (coarse == 0x3f) {
    coarse = 0x1f;
  }
  uint32_t fine =( *((uint32_t *)(NVMCTRL_OTP4)
                  + (NVM_SW_CALIB_DFLL48M_FINE_VAL / 32))
                  >> (NVM_SW_CALIB_DFLL48M_FINE_VAL % 32))
                  & ((1 << 10) - 1);
  if (fine == 0x3ff) {
    fine = 0x1ff;
  }
  dfllval_conf.bit.COARSE  = coarse;
  dfllval_conf.bit.FINE    = fine;
  dfllctrl_conf.bit.USBCRM = true;
  dfllctrl_conf.bit.BPLCKC = false;
  dfllctrl_conf.bit.QLDIS  = false;
  dfllctrl_conf.bit.CCDIS  = true;
  dfllctrl_conf.bit.ENABLE = true;

  SYSCTRL->DFLLCTRL.bit.ONDEMAND = false;
  while (!(SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY));
  SYSCTRL->DFLLMUL.reg = 48000;
  SYSCTRL->DFLLVAL.reg = dfllval_conf.reg;
  SYSCTRL->DFLLCTRL.reg = dfllctrl_conf.reg;

  GCLK_CLKCTRL_Type clkctrl={0};
  uint16_t temp;
  GCLK->CLKCTRL.bit.ID = 0; /* GCLK_ID - DFLL48M Reference */
  temp = GCLK->CLKCTRL.reg;
  clkctrl.bit.CLKEN = true;
  clkctrl.bit.WRTLOCK = false;
  clkctrl.bit.GEN = GCLK_CLKCTRL_GEN_GCLK0_Val;
  GCLK->CLKCTRL.reg = (clkctrl.reg | temp);

  /* Configure DFLL48M as source for GCLK_GEN1 */
  GCLK->GENCTRL.bit.ID = 1; /* GENERATOR_ID - GCLK_GEN_1 */
  while(GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY);
  temp_genctrl = GCLK->GENCTRL.reg;
  genctrl.bit.SRC = GCLK_GENCTRL_SRC_DFLL48M_Val;
  genctrl.bit.GENEN = true;
  genctrl.bit.RUNSTDBY = false;
  GCLK->GENCTRL.reg = (genctrl.reg | temp_genctrl);
  while(GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY);
#endif
}
