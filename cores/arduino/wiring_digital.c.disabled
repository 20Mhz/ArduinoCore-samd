/*
  Copyright (c) 2014 Arduino.  All right reserved.

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
  See the GNU Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/

#include "Arduino.h"

#ifdef __cplusplus
 extern "C" {
#endif

int pinPeripheral( uint32_t ulPin, EPioType ulPeripheral )
{
	if ( g_APinDescription[ulPin].ulPinType == PIO_NOT_A_PIN )
	{
		return ;
	}

	switch ( ulPeripheral )
	{
		case PIO_DIGITAL:
		case PIO_INPUT:
		case PIO_OUTPUT_0:
		case PIO_OUTPUT_1:
		  // Disable peripheral muxing
			PORT->Group[g_APinDescription[ulPin].ulPort]->PINCFG[g_APinDescription[ulPin].ulPin].bit.PMUXEN = 1 ;

      // Configure pin mode, if requested
			switch ( ulPeripheral )
			{
				case PIO_INPUT:
				  pinMode( ulPin, INPUT ) ;
				break ;

				case PIO_INPUT_PULLUP:
				  pinMode( ulPin, INPUT_PULLUP ) ;
				break ;

				case PIO_OUTPUT:
				  pinMode( ulPin, OUTPUT ) ;
				break ;
			}
		break ;

		case PIO_ANALOG:
			PORT->Group[g_APinDescription[ulPin].ulPort]->PMUX[g_APinDescription[ulPin].ulPin].
			PORT->Group[g_APinDescription[ulPin].ulPort]->PINCFG[g_APinDescription[ulPin].ulPin].bit.PMUXEN = 1 ;

      // Is the pio pin in the lower 16 ones?
			// The WRCONFIG register allows update of only 16 pin max out of 32
			if ( g_APinDescription[ulPin].ulPin < 16 )
			{
				PORT->Group[g_APinDescription[ulPin].ulPort]->WRCONFIG.reg=PORT_WRCONFIG_PMUXEN|PORT_WRCONFIG_PINMASK( g_APinDescription[ulPin].ulPin ) ;
			}
			else
			{
				PORT->Group[g_APinDescription[ulPin].ulPort]->WRCONFIG.reg=PORT_WRCONFIG_HWSEL | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_PMUXEN |  | PORT_WRCONFIG_PINMASK( g_APinDescription[ulPin].ulPin >> 16 ) ;
			}
			PORT_WRCONFIG_PMUX()
			PORT_WRCONFIG_WRPINCFG
			PORT_WRCONFIG_WRPMUX
			PORT_WRCONFIG_PINMASK()
		break ;

		case PIO_EXTINT:
		break ;

		case PIO_SERCOM:
		break ;

		case PIO_SERCOM_ALT:
		break ;

		case PIO_TIMER:
		break ;

		case PIO_TIMER_ALT:
		break ;

		case PIO_COM:
		break ;

		case PIO_AC_CLK:
		break ;

		case PIO_NOT_A_PIN:
			return -1 ;
		break ;
	}
}

void pinMode( uint32_t ulPin, uint32_t ulMode )
{
	if ( g_APinDescription[ulPin].ulPinType == PIO_NOT_A_PIN )
	{
		return ;
	}

	switch ( ulMode )
	{
		case INPUT:
		  // Set pin to input mode
			PORT->Group[g_APinDescription[ulPin].ulPort]->PINCFG[g_APinDescription[ulPin].ulPin].reg=(uint8_t)(PORT_PINCFG_INEN) ;
		  PORT->Group[g_APinDescription[ulPin].ulPort]->DIRCLR.reg = (uint32_t)(1<<g_APinDescription[ulPin].ulPin) ;
		break ;

		case INPUT_PULLUP:
		  // Set pin to input mode with pull-up resistor enabled
			PORT->Group[g_APinDescription[ulPin].ulPort]->PINCFG[g_APinDescription[ulPin].ulPin].reg=(uint8_t)(PORT_PINCFG_INEN|PORT_PINCFG_PULLEN) ;
		  PORT->Group[g_APinDescription[ulPin].ulPort]->DIRCLR.reg = (uint32_t)(1<<g_APinDescription[ulPin].ulPin) ;
		break ;

		case OUTPUT:
		  // Set pin to output mode
			PORT->Group[g_APinDescription[ulPin].ulPort]->PINCFG[g_APinDescription[ulPin].ulPin].reg&=~(uint8_t)(PORT_PINCFG_INEN) ;
		  PORT->Group[g_APinDescription[ulPin].ulPort]->DIRSET.reg = (uint32_t)(1<<g_APinDescription[ulPin].ulPin) ;
		break ;

		default:
		  // do nothing
		break ;
	}
}

void digitalWrite( uint32_t ulPin, uint32_t ulVal )
{
  /* Handle the case the pin isn't usable as PIO */
	if ( g_APinDescription[ulPin].ulPinType == PIO_NOT_A_PIN )
  {
    return ;
  }

  if ( PIO_GetOutputDataStatus( g_APinDescription[ulPin].pPort, g_APinDescription[ulPin].ulPin ) == 0 )
  {
    PIO_PullUp( g_APinDescription[ulPin].pPort, g_APinDescription[ulPin].ulPin, ulVal ) ;
  }
  else
  {
    PIO_SetOutput( g_APinDescription[ulPin].pPort, g_APinDescription[ulPin].ulPin, ulVal, 0, PIO_PULLUP ) ;
  }
}

int digitalRead( uint32_t ulPin )
{
  /* Handle the case the pin isn't usable as PIO */
	if ( g_APinDescription[ulPin].ulPinType == PIO_NOT_A_PIN )
	{
		return LOW ;
	}

	if ( (PORT->Group[g_APinDescription[ulPin].ulPort]->IN.reg & g_APinDescription[ulPin].ulPin) != 0 )
	{
		return HIGH ;
	}

	return LOW ;
}

#ifdef __cplusplus
}
#endif

